# 软件工程导论

##  软件工程学

* 软件工程产生原因 ———— 软件危机 20世纪60年代
* 软件工程 ***为了经济地获取可靠的且能在实际机器上有效运行的软件，而建立和使用的完整工程原理***
* 软件工程基本原理
  * 用分阶段的生命周期计划严格管理
  * 坚持运行阶段评审
  * 实行严格的产品控制
  * 采用现代程序设计技术
  * 结果应该能清楚审查
  * 开发小组的人应该少而精
  * 承认不断改进软件工程实践的必要性
* 软件生命周期
  * 软件定义
    * 问题定义
    * 可行性研究
    * 需求分析
  * 软件开发
    * 总体设计
    * 详细设计
    * 编码和单元测试
    * 综合测试
  * 运行维护
    * 软件维护
* 软件模型 *软件过程————是为了获得搞质量软件所需完成的一系列任务框架，它规定了完成各项任务的工作步骤*
  * 瀑布模型
    * 历史悠久，优势：规范化文档驱动的；缺点：不能好的应对用户变化的需求
  * 快速模型
    * 他快速构建起一个可在计算机上运行的原型系统，让用户使用原型并收集用户反馈获取用户真实需求
  * 增量模型
    * 可在软件开发早期阶段使投资获取明显的回报，比较易于维护，但要求软件具有开放的结构
  * 螺旋模型
    * 风险驱动，需要开发人员具有风险分析和排除风险的能力时，才容易成功
  * 喷泉模型

## 可行性研究
* 目的 
  * 用最小的代价在尽可能短的时间内确定问题是否能够解决
* 分类
  * 技术可行性
  * 经济可行性
  * 操作可行性
  * 法律，社会效益
* 过程
  * 复查系统规模和目标
  * 研究目前正在使用的系统
  * 导出新系统的高层逻辑
  * 进一步定义问题
  * 导出评价供选择的解法
  * 推荐行动方针
  * 草拟开发计划
  * 书写文档提交审查
* 系统流程图
* ***数据流图*** P41
* 数据字典
  * 数据定义 ***P48***

##  需求分析
* 任务
  * 确定系统的综合要求
    * 功能需求
    * 性能需求
    * 可靠性和可用性需求
    * 出错处理需求
    * 接口需求
    * 约束
    * 逆向需求
    * 将来可能提出的要求
  * 分析系统的数据要求
  * 导出系统的逻辑模型
  * 修正系统开发计划
* 分析建模与规格说明
  * 分析过程中的三种模型 
    * 数据模型
    * 功能模型
    * 行为模型
  * 实体联系图 E-R图
  * ***状态转化图*** P66
  * 其他
    * 层次方框图
    * warnier图
    * IPO图 *输入 处理 输出图*


## 总体设计
* 设计过程 
  * 设想方案
  * 挑选合理方案
  * 推荐最佳方案
  * 功能分解
  * 设计软件结构
  * 设计数据库
  * 指定测试计划
  * 书写文档
  * 审查和复审
* 设计原理
  * ***模块化*** P94
  * 抽象
  * 逐步求精
  * 信息隐藏和局部化
  * ***模块独立*** P97
    * 独立程度指标 内聚和耦合
* ***启发规则***
  1. 改进软件结构提高模块独立性
  2. 模块规模应该适中
  3. 深度，宽度，单出和单入都应当适当
  4. 模块的作用域应该在控制域之内
  5. 力争降低模块接口复杂程度
  6. 设计单入口单出口的模块
  7. 模块功能应该可以预测
* 描绘软件结构的图像工具
  * 层次图
  * HIPO图
  * 结构图



## 结构化设计
* 过程设计工具
  * 程序流程图
  * 盒图 *N-S图*
  * 问题分析图 *PAD图*
  * **判定表 判定树** P127
* 面向数据结构设计方法
  * jackson 方法
  * McCabe方法 *流图*
    * ***计算环形复杂度***
      * 流图中线性无关的区域数等于环形复杂度
      * 边的条数-节点数+2 = 环形复杂度
      * 判定节点数+1 = 环形复杂度
  * Halstead 方法

## 测试
* 目标
  * 为了发现程序中的错误而执行的过程
* 测试步骤
  * 模块测试 *单元测试*
  * 集成测试
    * 子系统测试
    * 系统测试
  * 验收测试
    * Alpha测试 *用户在开发者指导下进行测试*
    * Beta测试 *产品完全交给用户，收集用户反馈给开发者*
  * 平行运行
* 集成测试
  * 渐增式测试
    * 自顶向下集成
    * 自顶向上集成
  * 回归测试 *新模块结合进来时，可能建立起新的数据路径，需要根据新的路径重新测试*
* 分类
  * 功能测试 *黑盒测试*
    * 等价划分
    * 边界值分析
    * 错误推测
  * 结构测试 ***白盒测试*** P162
    * 对输入的数据进行追踪，测试数据流动与预期是否一致
    * 逻辑覆盖
      * 语句覆盖
      * 判定覆盖 *分支覆盖*
      * 条件覆盖
      * 判定/条件覆盖
      * 条件组合覆盖
      * 点覆盖
      * 边覆盖
      * 路径覆盖
    * 控制结构测试
      * 基本路径测试
      * 条件测试
      * 循环测试
* 调试
  * 是在测试发现错误之后排除错误的过程
  * 方法
    * 蛮干法
    * 回溯法
    * 原因排除法
* 可用性 *软件系统在投入使用时可操作和可访问的程度，或能实现其指定系统功能的概率*
* 可靠性 *在规格时间间隔内和规定条件下，系统或部件执行所要求功能的能力*

## 维护
* *软件在交付使用后，为了改正错误或者满足新的需求而修改软件的过程*
* 分类
  * 为了纠正正在使用过程中暴露出来的错误而进行的改正性维护
  * 为了适应外部环境变化而进行的适应性维护
  * 为了改进原有软件而进行的完善性维护
  * 为了改进将来的可维护性和可靠性而进行的预防性维护
* 可维护性  *维护人员理解，改正，改动或改进这个软件的难易程度*
  * 可理解性
  * 可测试性
  * 可修改性
  * 可移植性
  * 可重用性
* 软件再生工程
  * 目录分析
  * 文档重构
  * 逆向工程
  * 代码重构
  * 数据重构
  * 正向工程

## 面向对象方法学
* 三种基本模型
  * 对象模型 *做什么*
  * 动态模型 *什么时候做*
    * 用例 ***可以被行为者感受到的，系统的一个完整功能***
    * 脚本 ***指系统某一执行期间内出现的一系列事件***
    * 脚本是用例的实例
  * 功能模型 *谁来做*
* ***面向对象设计的准则***
  * 模块化
  * 抽象
  * 信息隐藏
  * 弱耦合
  * 强内聚
  * 可重用
* **软件重用**
  * 指同一事物不做修改或者稍加改动就可多次使用
  * 类别
    * 知识重用
    * 方法和标准的重用
    * 软件成分的重用 
      * 代码重用
      * 设计结果重用
      * 分析结果重用
* ***估计软件规模*** P305
  * 代码行技术
  * 功能点技术
* 工作量估计
  * 静态单变量模型
  * 动态多变量模型
  * COCOMO2模型 构造性成本模型
* 人员组织
  * 民主制程序员
  * 主程序员
  * 现代程序员
* 软件质量保证措施
  * 技术复审的必要性
  * 走查
  * 审查
  * 程序正确性证明





## 软件成熟度模式

CMM（Capability Maturity Model）是一种软件过程能力成熟度模型，用于评估和改进组织的软件开发过程。CMM模型定义了一组与软件开发相关的最佳实践，并将这些实践划分为不同的成熟度层级。

1. 初始级（Level 1 - Initial）：在初始级别，软件开发过程是非结构化和无序的，缺乏明确定义的过程。项目的成功主要依赖于个别人员的技术能力和努力。
2. 可重复级（Level 2 - Repeatable）：在可重复级别，组织开始建立基本的项目管理过程，确保项目的成果和过程能够重复。组织采取一些基本的过程纪律和管理实践，以确保项目的一致性和可重复性。
3. 定义级（Level 3 - Defined）：在定义级别，组织建立了一套定义明确、可量化和可管理的软件开发过程。这些过程被记录、标准化和追踪，以确保项目的可控性和可预测性。
4. 管理级（Level 4 - Managed）：在管理级别，组织通过收集和分析过程和项目数据，对软件开发过程进行量化和管理。通过指标和度量，组织能够及时调整和改进过程，以实现更高的质量和效率。
5. 优化级（Level 5 - Optimizing）：在优化级别，组织不断追求卓越和创新，通过分析数据、持续改进和技术创新来优化软件开发过程。组织采取主动的态度，通过尝试新的方法和技术来提高过程的效能和竞争力。





## ISO/IEC 9126 软件质量度量模型

的质量特性包括:

1. 可靠性：软件在规定的条件下，能够按照预定的要求和用途长期稳定地运行，不会出现故障或意外行为。
2. 可用性：软件能够满足用户的需求和期望，使用户能够方便地使用软件，并能够准确地找到和使用所需的功能。
3. 性能：软件在运行时的性能，包括响应时间、吞吐量、资源利用率等，能够满足用户需求和期望。
4. 安全性：软件具有适当的安全性，包括防病毒、加密、访问控制等，能够保护用户数据和隐私不受恶意攻击和侵害。
5. 可维护性：软件在运行过程中能够方便地被维护和修改，以满足新的用户需求和变化。
6. 可测试性：软件能够方便地被测试和验证，以确保软件的质量和可靠性。
